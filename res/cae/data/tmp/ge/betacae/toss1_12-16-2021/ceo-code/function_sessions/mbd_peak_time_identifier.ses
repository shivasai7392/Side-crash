//#!python
# PYTHON script
import meta
from meta import *

def main():
	
	#Get the target model ID
	model_id = int(utils.MetaGetVariable('model'))

	#Survival space info
	scale = int(utils.MetaGetVariable('ss_scale'))
	offset = int(utils.MetaGetVariable('ss_offset'))

	#Survival space info
	upper_bound = float(utils.MetaGetVariable('ss_upper_bound'))
	lower_bound = float(utils.MetaGetVariable('ss_lower_bound'))

	print("SCALE : "+str(scale)+" | OFFSET : "+str(offset)+" | REGION : "+str(lower_bound)+" --> "+str(upper_bound))

	#Generate model and part objects
	m = models.Model(model_id)
	all_parts = m.get_parts('all')
	
	#Get the search parameter for the B-PLR INNER
	hes_search = str(utils.MetaGetVariable('bplr_accels_hes'))
	print("HES ORIGINAL SEARCH STRING : "+hes_search)
	hes_search = hes_search.strip(chr(42))
	print("HES NO WILDCARD: "+hes_search)


	#Search all the parts in the model for the B-PLR INNER
	hes_flag = 0
	for part in all_parts:
		if hes_search in part.name:
			hes_flag = 1
			break

	#Throw an error if nothing is found
	if hes_flag == 0:
		print("Part not found!!")

	#Make part object for B-PLR INNER
	part = parts.Part(part.id, type=constants.PSHELL, model_id=m.id)

	#Get Follow nodes
	utils.MetaSetVariable('target_variable','follow_nodes')
	utils.MetaSetVariable('target_sort','z')
	utils.MetaCommand('read session ${code_source_path}/in_development/node_string_generator.ses')
	follow_nodes = str(utils.MetaGetVariable('dem_nodes')).split(chr(47))

	#Check if the follow nodes list has a length different than 3, if so throw error messsage
	if not(len(follow_nodes) == 3):
		print('More or less than 3 nodes input for follow nodes! Data will be wrong!')

	#Get B-PLR survival space nodes
	utils.MetaSetVariable('target_variable','original_bplr_ss_nodes')
	utils.MetaCommand('read session ${code_source_path}/in_development/node_string_generator.ses')
	bplr_ss_nodes = str(utils.MetaGetVariable('dem_nodes')).split(chr(47))

	#Apply follow nodes to the model
	nodes.ApplyFollowNodes(m.id, follow_nodes)

	#Get results object
	all_results = m.get_resultsets()

	#Determine the minimum and final survival space and when it occurs
	ss_min = 10000000000000000000000000000000
	ss_final_min = 10000000000000000000000000000000

	for result in all_results:
		for node_id in bplr_ss_nodes:
			node = nodes.Node(int(node_id),m.id)
			nd = node.get_coordinates(result)
			ss = nd.y*scale - offset
			if (len(all_results)-1) == all_results.index(result):
				if ss < ss_final_min:
					if (nd.z > lower_bound) and (nd.z < upper_bound):
						ss_final_min = ss
						ss_final_node = node_id
						ss_final_node_z = nd.z
						ss_final_node_y = nd.y
						final_time = result.time * 1000.0
			else:
				if ss < ss_min:
					if (nd.z > lower_bound) and (nd.z < upper_bound):
						ss_min = ss
						ss_node = node_id
						ss_node_z = nd.z
						ss_node_y = nd.y
						peak_time = result.time
						peak_time_display = result.time * 1000.0

	#Print computed data for the users viewing pleasure
	print("PEAK SURVIVAL SPACE : "+str(ss_min))
	print("PEAK TIME : "+str(peak_time))
	print("PEAK NODE : "+str(ss_node)+' | Y : '+str(ss_node_y)+' | Z : '+str(ss_node_z))
	print("")
	print("FINAL SURVIVAL SPACE : "+str(ss_final_min))
	print("FINAL NODE : "+str(ss_final_node)+' | Y : '+str(ss_final_node_y)+' | Z : '+str(ss_final_node_z))
	print('SCALE : '+str(scale)+' | OFFSET '+str(offset))

	#Pass the data back to meta
	utils.MetaSetVariable('peak_time', str(peak_time))
	utils.MetaSetVariable('peak_time_display', str(peak_time_display))
	utils.MetaSetVariable('target_state', str(peak_time))
	utils.MetaSetVariable('survival-space_final', str(ss_final_min))
	utils.MetaSetVariable('survival-space_peak', str(ss_min))
	utils.MetaSetVariable('survival-space_final_time', str(final_time))
	utils.MetaSetVariable('survival-space_peak_time', str(peak_time))
if __name__ == '__main__':
	main()
//#!EOF

