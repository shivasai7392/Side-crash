$---------- SCRIPT TO GENERATE NODE STRING (dem_nodes) TO EXTRACT DATA WITH BASED ON WHATEVER THE USER WANTS
$
$-- Model ID to extract the data from
$opt var add target_model 1
$
$-- Direction to sort the node string (optional)
$-- Sort directions >> x y z X Y Z
$opt var add target_sort x
$
$-- Target nodes can be a list of IDs or names
$-- Delimeters >> , \ / : ; (vertical tab) (space)
$opt var string target_nodes Bplr_Hip_Height,Bplr_WSid_Shldr_Height
$opt var string target_nodes 900407,900307,900356
$opt var string target_nodes 32703148/32703157/32703162/33044829/33044838/33044843/33046128/33047410/33048692/33049974/33049982/33051265/33057313
$opt var add target_variable target_nodes
$
$-- Path to the binout file (if you are using names you NEED this)
$opt var add b0 "binout*"
$opt var add pA "${PWD}/${b0}"
$opt var add pA "/cae/data/tmp/fr2/ra067381/3NT/02_SIDE/01_SICE_2p0_CORRELATION/118_TRIAL-2_CLEAN/message_files/binout*"
$
$--

//#!python
# PYTHON script
import meta
from meta import *

def main():

	error_flag = 0

	# Import target mode ID -- needs to be integer
	target_model = int(utils.MetaGetVariable('target_model'))
	m = models.Model(target_model)
	
	# Import target node list
	try:
		target_variable = str(utils.MetaGetVariable('target_variable'))
		node_user_input = str(utils.MetaGetVariable(target_variable))
		print("---")
		print("")
		print("NODE USER INPUT : "+node_user_input+" | FROM VARIABLE : "+target_variable)
	except:
		target_variable = str(utils.MetaGetVariable('target_variable'))
		node_user_input = str(utils.MetaGetVariable('target_nodes'))
		print("---")
		print("")
		print("TRIED AND FAILED TO UTILIZE : "+target_variable)
		print("FALLBACK VARIABLE PULLED : target_nodes")

	# STRIP OFF QUOTATIONS OR ANY OTHER CORRUPTING CHARACTERS
	# STRIPPED CHARACTERS : [ " '  ]
	stripped_characters = [chr(34) ,chr(39)]

	# SEARCHS DELIMETERS FIRST TO LAST AND BREAKS WHEN ONE IS FOUND
	# DELIMETERS SEARCH : [ , / \ : ; (vertical tab) (space)]
	delimeters = [chr(44) ,chr(47) ,chr(92) ,chr(58) ,chr(59) ,chr(11), chr(32)]
	for d in delimeters:
		if (node_user_input.find(d) != -1):
			target_delimeter = d
			if (target_delimeter != chr(32)):
				stripped_characters.append(chr(32))
			break

	# Split user input based on delimeter used
	target_nodes = []
	try:
		target_nodes = node_user_input.split(target_delimeter)
	except:
		target_nodes.append(node_user_input)
	python_unsorted_node_db = []

	# Generating list of numbers to search against
	number_characters = []
	for i in range(48,57):
		number_characters.append(chr(i))
	
	letter_characters = []
	# Generating list of upper case letters to search against
	for i in range(65,90):
		letter_characters.append(chr(i))
	# Adding lower case numbers to letter search list
	for i in range(97,122):
		letter_characters.append(chr(i))

	number_flag = 0
	total_letter_flag = 0
	for thing in target_nodes:
		# Determine the type of list the user made
		for number in number_characters:
			if number in thing:
				number_flag=1
				break
		for letter in letter_characters:
			if letter in thing:
				total_letter_flag=1
				break
		location = target_nodes.index(thing)
		for s in stripped_characters:
			target_nodes[location] = target_nodes[location].strip(s)

	# Search the binout
	filename = str(utils.MetaGetVariable('pA'))
	curve_types = plot2d.CurvesTypesDynaWithNames(filename)
	search_nodes = []
	identified = []

	for one_type in curve_types:
		type = one_type[0]
		if (type == 'nodout-Node'):
			entities = one_type[1] #List with entities ids
			for one_entity in entities:
				logged = 0
				entity_id = one_entity[0] # Id of entity
				entity_name = one_entity[1] # Name of entity
				if (entity_name in target_nodes):
					try:
						is_it_real = target_nodes.index(entity_name)
						search_nodes.append(str(entity_id))
						identified.append(target_nodes[is_it_real])
						logged = 1
					except:
						false_positive = 1
				if str(entity_id) in target_nodes and (logged == 0):
					try:
						is_it_real = target_nodes.index(entity_id)
						search_nodes.append(target_nodes[is_it_real])
						identified.append(target_nodes[is_it_real])
					except:
						false_positive = 1
			break

	misfit_nodes = []
	for check in target_nodes:
		if check not in identified:
			misfit_nodes.append(check)
	
	if (len(misfit_nodes) > 0) and (number_flag == 1):
		geo_check_nodes = m.get_nodes('all')
		for thing in misfit_nodes:
			for n in geo_check_nodes:
				if str(n.id) == thing:
					search_nodes.append(str(n.id))
					break

	# Carry over target string if nothing found in binout
	if len(search_nodes) == 0:
		print("User input nodes not found in binout!")
		error_flag=1
		search_nodes = target_nodes

	# Search for the nodes in the model
	for node in search_nodes:
		try:
			tmp = m.get_nodes('all', node_id = int(node))
			node_data = tmp[0]
			python_unsorted_node_db.append(node_data)
		except:
			print("Cannot find user input node : "+str(node))
			error_flag=1

	# Sort the data if a direction is specified by the user
	sort_direction = str(utils.MetaGetVariable('target_sort'))
	if sort_direction in ['x','y','z','X','Y','Z']:
		print("SORT DIR : "+sort_direction)
		python_sorted_node_db = nodes.SortNodeList(target_model, python_unsorted_node_db,0,0, sort_direction)
		python_node_db = python_sorted_node_db
	else:
		python_node_db = python_unsorted_node_db

	# Node string is always delimeted by /
	node_string_delimeter = chr(47)

	output_unsorted_node_string = ''
	python_index = len(python_unsorted_node_db)

	# Generate the unsorted output string
	for n in python_unsorted_node_db:
		if python_unsorted_node_db.index(n) == (python_index-1):
			output_unsorted_node_string = output_unsorted_node_string + str(n.id)
		else:
			output_unsorted_node_string = output_unsorted_node_string + str(n.id) + node_string_delimeter

	output_node_string = ''
	python_index = len(python_node_db)

	# Generate the unsorted output string
	for n in python_node_db:
		if python_node_db.index(n) == (python_index-1):
			output_node_string = output_node_string + str(n.id)
		else:
			output_node_string = output_node_string + str(n.id) + node_string_delimeter

	#Pass the output string to meta
	utils.MetaSetVariable('dem_nodes', output_node_string)

	if sort_direction in ['x','y','z','X','Y','Z']:
		print("UNSORTED STRING : "+output_unsorted_node_string)
		print("SORTED STRING : "+output_node_string)
	print("")

if __name__ == '__main__':
	main()
//#!EOF