$-- MEASUREMENT LINES FROM THE D3PLOT DATA BASED ON USER INPUT

$-- CODE PATH NEEDS NO / AT THE END
opt var add code_source_path "/cae/data/reference/fr2/_DevelopmentCAE/04_Scripts/phase1_sessions/function_sessions"
opt var add mode_source_path "/cae/data/reference/fr2/_DevelopmentCAE/04_Scripts/phase1_sessions/mode_sessions/in_development"
opt var add log_source_path "/cae/data/reference/fr2/_DevelopmentCAE/04_Scripts/phase1_to_excel_sessions/mode_sessions/in_development"

//#!python
# PYTHON script
import os
import meta
from meta import *

def main():

	print("")
	print("---GUI INTRUSION LINES")
	print("")

	global accept
	accept = -1

	#Set up the pop up window object
	window = guitk.BCWindowCreate( "measurement line user input", guitk.constants.BCOnExitDestroy)

	#Purge and create new checkbox
	purgeEnable = guitk.BCCheckBoxCreate(window, "Purge and Create new output 2D window?")
	guitk.BCCheckBoxSetChecked(purgeEnable, False)
	guitk.BCCheckBoxSetToggledFunction(purgeEnable,None,None)

	#Node pick checkbox
	pickEnable = guitk.BCCheckBoxCreate(window, "Pick nodes ?")
	guitk.BCCheckBoxSetChecked(pickEnable, False)
	guitk.BCCheckBoxSetToggledFunction(pickEnable,None,None)

	all_models = utils.get_models('all')

	#Dropdown menu for what model to target
	hlm = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	labelm = guitk.BCLabelCreate( hlm, "What is your target model?" )
	modelCombo = guitk.BCComboBoxCreate( hlm, None )
	iter = 0
	for model in all_models:
		guitk.BCComboBoxInsertItem( modelCombo, str(model.id), iter )
		iter = iter + 1

	#Dropdown menu for x-axis dir + y-axis dir
	hlx = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	labelx = guitk.BCLabelCreate( hlx, "What direction should be on the X-axis?" )
	xAxxisCombo = guitk.BCComboBoxCreate( hlx, None )
	guitk.BCComboBoxInsertItem( xAxxisCombo, "X", 0 )
	guitk.BCComboBoxInsertItem( xAxxisCombo, "Y", 1 )
	guitk.BCComboBoxInsertItem( xAxxisCombo, "Z", 2 )
	guitk.BCComboBoxSetCurrentItem( xAxxisCombo, 0)

	labely = guitk.BCLabelCreate( hlx, "What direction should be on the Y-axis?" )
	yAxxisCombo = guitk.BCComboBoxCreate( hlx, None )
	guitk.BCComboBoxInsertItem( yAxxisCombo, "X", 0 )
	guitk.BCComboBoxInsertItem( yAxxisCombo, "Y", 1 )
	guitk.BCComboBoxInsertItem( yAxxisCombo, "Z", 2 )
	guitk.BCComboBoxSetCurrentItem( yAxxisCombo, 1)

	#Dropdown menu for sort direction
	hls = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	labels = guitk.BCLabelCreate( hls, "What axis should the data be sorted for?")
	sortCombo = guitk.BCComboBoxCreate( hls, None )
	guitk.BCComboBoxInsertItem( sortCombo, "X-axis", 0 )
	guitk.BCComboBoxInsertItem( sortCombo, "Y-axis", 1 )

	#Source 3D window input field
	hlu = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hlu, "Source 3D window : ")
	led = guitk.BCLineEditCreate(hlu, "MetaPost")
	guitk.BCLineEditSetPlaceholderText(led, "Where do you want to source 3D data from?")
	guitk.BCLineEditSetEnterPressedFunction(led, None, None)

	#Follow node input field
	hlf = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hlf, "Follow nodes : ")
	lef = guitk.BCLineEditCreate(hlf, "7,8,9")
	guitk.BCLineEditSetPlaceholderText(lef, "What are your follow nodes?")
	guitk.BCLineEditSetEnterPressedFunction(lef, None, None)

	guitk.BCLabelCreate(hlf, "What states do you want to measure?")
	try:
		trial = str(utils.MetaGetVariable('user_input_plot_states_string'))
		if len(trial) > 0:
			print('Imported plot state string used!')
		else:
			trial = "1-77-5"
	except:
		print('No previous plot state string found!')
		trial = "1-77-5"
	lest = guitk.BCLineEditCreate(hlf, trial)
	guitk.BCLineEditSetPlaceholderText(lest, "What states do you want to measure?")
	guitk.BCLineEditSetEnterPressedFunction(lest, None, None)

	#Ouput 2D window input field
	hlo = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hlo, "Output 2D window : ")
	leo = guitk.BCLineEditCreate(hlo, "something")
	guitk.BCLineEditSetPlaceholderText(leo, "What window should the 2D data be output in?")
	guitk.BCLineEditSetEnterPressedFunction(leo, None, None)

	guitk.BCLabelCreate(hlo, "Output 2D plot ID: ")
	lewi = guitk.BCLineEditCreate(hlo, "0")
	guitk.BCLineEditSetPlaceholderText(lewi, "What plot id should the 2D data be output in?")
	guitk.BCLineEditSetEnterPressedFunction(lewi, None, None)

	#Prefix input field
	hlp = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hlp, "Prefix : ")
	lep = guitk.BCLineEditCreate(hlp, "some_prefix_")
	guitk.BCLineEditSetPlaceholderText(lep, "What should be the prefix for output curves?")
	guitk.BCLineEditSetEnterPressedFunction(lep, None, None)

	#Color selection
	hlc = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hlc, "Color : ")
	try:
		trial = str(utils.MetaGetVariable('color'))
		if len(trial) > 0:
			print('Imported previous color used!')
		else:
			trial = "0_0_0"
	except:
		print('No previous color found!')
		trial = "0_0_0"
	lec = guitk.BCLineEditCreate(hlc, trial)
	guitk.BCLineEditSetPlaceholderText(lec, "R_G_B")
	tbut = guitk.BCPushButtonCreate(hlc, "Change color", colorSelectFunc, [lec])
	guitk.BCBoxLayoutSetDirection(hlc, guitk.constants.BCLeftToRight)

	#Node string if user dosen't want to pick
	hln = guitk.BCBoxLayoutCreate(window, guitk.constants.BCHorizontal)
	guitk.BCLabelCreate(hln, "Node string : ")
	try:
		trial = str(utils.MetaGetVariable('plot_nodes'))
	except:
		print('No previous node string found!')
		trial = "something"
	lesn = guitk.BCLineEditCreate(hln, trial)
	guitk.BCLineEditSetPlaceholderText(lesn, "What node string should be used for measurements?")
	guitk.BCLineEditSetEnterPressedFunction(lesn, None, None)
	guitk.BCCheckBoxAddManagedWidget(pickEnable, lesn, guitk.constants.BCManagedDisable,guitk.constants.BCManagedEnable)

	dbb = guitk.BCDialogButtonBoxCreate(window)
	guitk.BCWindowSetAcceptFunction(window, acceptFunc, None)
	guitk.BCWindowSetRejectFunction(window, rejectFunc, None)

	print('Collecting the user input!')

	answer = guitk.BCShow(window)

	if accept == 1:

		indexModel = guitk.BCComboBoxCurrentItem(modelCombo)
		print('Source model : ' +guitk.BCComboBoxGetText(modelCombo,indexModel))
		utils.MetaSetVariable('target_model', str(guitk.BCComboBoxGetText(modelCombo,indexModel)))
		utils.MetaSetVariable('model', str(guitk.BCComboBoxGetText(modelCombo,indexModel)))
		m = models.Model(int(guitk.BCComboBoxGetText(modelCombo,indexModel)))
		model_id = guitk.BCComboBoxGetText(modelCombo,indexModel)

		tmp_res = m.get_resultsets()

		m_path = os.path.join(os.path.dirname(tmp_res[1].get_filename()),'binout*')
		utils.MetaSetVariable('pA', m_path)

		print('Source 3D window : '+guitk.BCLineEditGetText(led))
		utils.MetaSetVariable('d3plot_data', str(guitk.BCLineEditGetText(led)))

		print('Follow nodes : '+guitk.BCLineEditGetText(lef))
		utils.MetaSetVariable('follow_nodes', str(guitk.BCLineEditGetText(lef)))

		user_node_string_commands = []
		user_node_string_commands.append('read session ${code_source_path}/src/node_string_generator.ses')

		indexaX = guitk.BCComboBoxCurrentItem(xAxxisCombo)
		print('X-axis direction : ' +guitk.BCComboBoxGetText(xAxxisCombo,indexaX))

		if indexaX == 0:
			x_axis_dir_string = 'XCoordinate'
			x_axis_dir_sort = 'x'
			x_axis_dir = 'X'
		if indexaX == 1:
			x_axis_dir_string = 'YCoordinate'
			x_axis_dir_sort = 'y'
			x_axis_dir = 'Y'
		if indexaX == 2:
			x_axis_dir_string = 'ZCoordinate'
			x_axis_dir_sort = 'z'
			x_axis_dir = 'Z'

		indexaY = guitk.BCComboBoxCurrentItem(yAxxisCombo)
		print('Y-axis direction : ' +guitk.BCComboBoxGetText(yAxxisCombo,indexaY))

		if indexaY == 0:
			y_axis_dir_string = 'X_coordinate'
			y_axis_dir_sort= 'x'
			y_axis_dir = 'X'
		if indexaY == 1:
			y_axis_dir_string = 'Y_coordinate'
			y_axis_dir_sort= 'y'
			y_axis_dir = 'Y'
		if indexaY == 2:
			y_axis_dir_string = 'Z_coordinate'
			y_axis_dir_sort= 'z'
			y_axis_dir = 'Z'

		indexSort = guitk.BCComboBoxCurrentItem(sortCombo)
		print('Sort axis : ' +str(guitk.BCComboBoxGetText(sortCombo,indexSort)))

		if indexSort == 0:
			utils.MetaSetVariable('target_sort',x_axis_dir_sort)
		if indexSort == 1:
			utils.MetaSetVariable('target_sort',y_axis_dir_sort)

		print('Output states : '+guitk.BCLineEditGetText(lest))
		user_input_plot_states_string = str(guitk.BCLineEditGetText(lest))
		utils.MetaSetVariable('user_input_plot_states_string',user_input_plot_states_string)

		print('Output 2D window : '+guitk.BCLineEditGetText(leo))
		window_name = guitk.BCLineEditGetText(leo)
		utils.MetaSetVariable('window', guitk.BCLineEditGetText(leo))

		print('Output 2D plot id : '+guitk.BCLineEditGetText(lewi))
		utils.MetaSetVariable('window_id', guitk.BCLineEditGetText(lewi))

		print('Prefix : '+guitk.BCLineEditGetText(lep))
		utils.MetaSetVariable('name', str(guitk.BCLineEditGetText(lep)))

		print('Color : '+guitk.BCLineEditGetText(lec))
		utils.MetaSetVariable('color', str(guitk.BCLineEditGetText(lec)))

		purge_flag = guitk.BCCheckBoxIsChecked(purgeEnable)
		print('Purge ? '+str(purge_flag))

		pick_flag = guitk.BCCheckBoxIsChecked(pickEnable)
		print('Pick ? '+str(pick_flag))

		if pick_flag:

			pick_commands = []
			pick_commands.append('window active none')
			pick_commands.append('window active "${d3plot_data}"')
			pick_commands.append('model active ${model}')
			pick_commands.append('view fo3 ${follow_nodes}')
			pick_commands.append('identify reset')
			for command in pick_commands:
				utils.MetaCommand(command)

			message = 'Pick Nodes and press Enter when you are ready'

			picked = m.pick_nodes(message)

			picked_start = 0
			plot_nodes_string = ''
			for node in picked:
				if len(plot_nodes_string) == 0:
					plot_nodes_string = str(node.id)
				else:
					plot_nodes_string = plot_nodes_string + ',' + str(node.id)
			utils.MetaCommand('window active none')

		else:

			plot_nodes_string = guitk.BCLineEditGetText(lesn)

		utils.MetaSetVariable('gui_plot_nodes', str(plot_nodes_string))
		utils.MetaSetVariable('target_variable', 'gui_plot_nodes')
		print('input nodes : '+plot_nodes_string)

		for command in user_node_string_commands:
			utils.MetaCommand(command)

		if purge_flag:
			command = "window delete ${window}"
			utils.MetaCommand(command)
			command = "xyplot create ${window}"
			utils.MetaCommand(command)
			print('Created new 2D window!')

		plot_nodes_processed = str(utils.MetaGetVariable('dem_nodes'))
		utils.MetaSetVariable('plot_nodes',plot_nodes_processed)

		# SEARCHS DELIMETERS FIRST TO LAST AND BREAKS WHEN ONE IS FOUND
		# DELIMETERS SEARCH : [ , / \ : ; (vertical tab) (space)]
		delimeters = [chr(44) ,chr(47) ,chr(92) ,chr(58) ,chr(59) ,chr(11), chr(32)]

		# STRIP OFF QUOTATIONS OR ANY OTHER CORRUPTING CHARACTERS
		# STRIPPED CHARACTERS : [ " '  ]
		stripped_characters = [chr(34) ,chr(39)]

		for d in delimeters:
			if (user_input_plot_states_string.find(d) != -1):
				print("USER INPUT SEVERAL STATES WITH "+ str(d)+ " DELIMETER")
				target_delimeter = d
				if (target_delimeter != chr(32)):
					stripped_characters.append(chr(32))
				break

		# Split user input based on delimeter used
		target_states = []
		try:
			target_states = user_input_plot_states_string.split(target_delimeter)
		except:
			target_states.append(user_input_plot_states_string)

		print("USER INPUT TARGET STATES : ")
		print(target_states)

		output_time_array = []
		resultsets = m.get_resultsets() 

		for thing in target_states:

			time_flag = 0
			state_flag = 0

			if chr(46) in thing:
				time_flag = 1
			else:
				state_flag = 1

			if chr(45) in thing:

				string_thing = str(thing)
				several_state_input = string_thing.split(chr(45))
				
				print('START : '+str(several_state_input[0]))
				print('END : '+str(several_state_input[1]))
				print('STEP : '+str(several_state_input[2]))

				output_time_array = []
				tmp_array = []

				if time_flag == 1:
					first_time = several_state_input[0]
					end_time = several_state_input[1]
					step = several_state_input[2]
					step_min = float(step)*0.9
					for res in resultsets:
						try:
							if first_time in str(res.time) and len(tmp_array) == 0:
								output_time_array.append(res.time)
								last_time = res.time
								tmp_array.append(res.time)
								continue
							elif float(first_time) < float(res.time) < float(end_time):
								if abs(float(res.time) - last_time) >= float(step_min):
									output_time_array.append(res.time)
									last_time = float(res.time)
									tmp_array.append(res.time)
									continue
							elif end_time in str(res.time):
								output_time_array.append(res.time)
								tmp_array.append(res.time)
								break
						except:
							print('Cannot find target time in model : '+str(first_time))
				if state_flag == 1:
					first_step = str(several_state_input[0])
					last_step = float(first_step)
					end_step = str(several_state_input[1])
					step = str(several_state_input[2])
					step_min = float(step)*0.9
					for res in resultsets:
						try:
							if first_step in str(res.step) and len(tmp_array) == 0:
								output_time_array.append(res.time)
								tmp_array.append(res.time)
								continue
							elif float(first_step) < float(res.step) < float(end_step):
								if abs(float(res.step) - last_step) >= float(step_min):
									output_time_array.append(res.time)
									last_step = float(res.step)
									tmp_array.append(res.time)
									continue
							elif end_step in str(res.step):
								output_time_array.append(res.time)
								tmp_array.append(res.time)
								break
						except:
							print('Cannot find target state in model : '+str(first_step))
			else:
				for res in resultsets:
					try:
						if time_flag == 1:
							if thing in str(res.time):
								output_time_array.append(res.time)
								break
						if state_flag == 1:
							if thing in str(res.step):
								output_time_array.append(res.time)
								break
					except:
						print('Cannot find target state / time in model : '+str(thing))

		try:
			first = output_time_array[0]
			print('PARSED TIME STATES : ')
			print(output_time_array)
		except:
			print('no output time array!')
			first = 'null'
			print("Can't plot if I dont have the right states!")

		startup_commands = []
		startup_commands.append('window active  "${d3plot_data}"')
		startup_commands.append('model active ${model}')
		startup_commands.append('view fo3 ${follow_nodes}')
		startup_commands.append('option state variable "time='+str(first)+'"')
		startup_commands.append('window active none')

		iter = 0
		for command in startup_commands:
			utils.MetaCommand(command)
			iter = iter + 1

		critical_command = 'xyplot linepick nodes "'+window_name+'" '+str(model_id)+' "'+plot_nodes_processed+'" '+y_axis_dir_string+' '+x_axis_dir_string+' current current'
		print(critical_command)

		for state_time in output_time_array:

			time_display = str(round((float(state_time)*1000),0))

			measurement_line_commands = []
			measurement_line_commands.append('window active "${d3plot_data}"')
			measurement_line_commands.append('options state variable "time='+str(state_time)+'"')
			measurement_line_commands.append('window active none')
			measurement_line_commands.append('window active "${window}"')
			measurement_line_commands.append('xyplot plotactive "${window}" ${window_id}')
			measurement_line_commands.append('xyplot curve visible not "${window}" all')
			measurement_line_commands.append(critical_command)
			measurement_line_commands.append('xyplot curve set name "${window}" ${LAST_CURVE_ID} "${name}_' + y_axis_dir+'_'+x_axis_dir+'_'+time_display +'_MS"')
			measurement_line_commands.append('xyplot curve set linewidth "${window}" visible 3')
			measurement_line_commands.append('xyplot curve set color "${window}" visible ${color}')
			measurement_line_commands.append('xyplot curve visible not "${window}" all')
			measurement_line_commands.append('xyplot plotdeactive "${window}" ${window_id}')
			measurement_line_commands.append('window active none')

			iter = 0
			for command in measurement_line_commands:
				utils.MetaCommand(command)
				iter = iter + 1

def colorSelectFunc(window, data):
	print('select color function activated!!')
	init_r = 123
	init_g = 123
	init_b = 123
	picked_color = guitk.BCGetColor(init_r,init_g,init_b)
	print('User picked R : '+str(picked_color[0])+' G : '+str(picked_color[1])+' B : '+str(picked_color[2]))
	picked_color = str(picked_color[0])+'_'+str(picked_color[1])+'_'+str(picked_color[2])
	guitk.BCLineEditSetText(data[0],picked_color)
	return 0


def acceptFunc(window, data):
	print("Measurement line curve generator enabled!")
	global accept
	accept = 1
	return guitk.constants.BCEventDestroy

def rejectFunc(window, data):
	print("Measurement line curve generator cancelled!")
	global accept
	accept = 0
	return guitk.constants.BCEventDestroy

if __name__ == '__main__':
	main()
//#!EOF